#!/usr/bin/env node
/**
 * Fetches ECO opening data from lichess-org/chess-openings and generates
 * a TypeScript data file at src/data/openings.ts.
 *
 * Usage: node scripts/generate-openings.mjs
 */

import { writeFileSync } from "fs";
import { join, dirname } from "path";
import { fileURLToPath } from "url";
import { Chess } from "chess.js";

const __dirname = dirname(fileURLToPath(import.meta.url));

const TSV_URLS = [
  "https://raw.githubusercontent.com/lichess-org/chess-openings/master/a.tsv",
  "https://raw.githubusercontent.com/lichess-org/chess-openings/master/b.tsv",
  "https://raw.githubusercontent.com/lichess-org/chess-openings/master/c.tsv",
  "https://raw.githubusercontent.com/lichess-org/chess-openings/master/d.tsv",
  "https://raw.githubusercontent.com/lichess-org/chess-openings/master/e.tsv",
];

async function fetchTsv(url) {
  const res = await fetch(url);
  if (!res.ok) throw new Error(`Failed to fetch ${url}: ${res.status}`);
  return res.text();
}

function parseTsv(text) {
  const lines = text.trim().split("\n");
  // Skip header: "eco\tname\tpgn"
  return lines.slice(1).map((line) => {
    const [eco, name, pgn] = line.split("\t");
    return { eco, name, pgn };
  });
}

function pgnToSanMoves(pgn) {
  return pgn
    .replace(/\d+\.\s*/g, "")
    .split(/\s+/)
    .filter((m) => m.length > 0);
}

function moveToUci(move) {
  return move.from + move.to + (move.promotion || "");
}

async function main() {
  console.log("Fetching ECO opening data from lichess...");

  const allOpenings = [];

  for (const url of TSV_URLS) {
    const letter = url.match(/\/([a-e])\.tsv/)?.[1]?.toUpperCase();
    console.log(`  Fetching ${letter}.tsv...`);
    const text = await fetchTsv(url);
    const entries = parseTsv(text);
    console.log(`    ${entries.length} openings`);
    allOpenings.push(...entries);
  }

  console.log(`Total: ${allOpenings.length} openings`);
  console.log("Processing with chess.js...");

  let errors = 0;
  const processed = [];

  for (const entry of allOpenings) {
    const sanMoves = pgnToSanMoves(entry.pgn);
    const chess = new Chess();
    const uciMoves = [];
    let valid = true;

    for (const san of sanMoves) {
      try {
        const move = chess.move(san);
        if (!move) {
          valid = false;
          break;
        }
        uciMoves.push(moveToUci(move));
      } catch {
        valid = false;
        break;
      }
    }

    if (!valid) {
      errors++;
      continue;
    }

    processed.push({
      eco: entry.eco,
      name: entry.name,
      moves: sanMoves,
      uci: uciMoves,
      fen: chess.fen(),
    });
  }

  if (errors > 0) {
    console.log(`  Skipped ${errors} entries with invalid PGN`);
  }
  console.log(`  ${processed.length} valid openings`);

  // Generate TypeScript
  let ts = `// Auto-generated by scripts/generate-openings.mjs\n`;
  ts += `// Source: https://github.com/lichess-org/chess-openings (public domain)\n`;
  ts += `// Total: ${processed.length} openings\n\n`;
  ts += `import type { Opening } from "../types/openings";\n\n`;
  ts += `export const OPENINGS: Opening[] = [\n`;

  for (const opening of processed) {
    const movesStr = opening.moves.map((m) => `"${m}"`).join(", ");
    const uciStr = opening.uci.map((m) => `"${m}"`).join(", ");
    ts += `  { eco: "${opening.eco}", name: ${JSON.stringify(opening.name)}, moves: [${movesStr}], uci: [${uciStr}], fen: "${opening.fen}" },\n`;
  }

  ts += `];\n`;

  const outPath = join(__dirname, "..", "src", "data", "openings.ts");
  writeFileSync(outPath, ts, "utf-8");
  console.log(`\nWritten to ${outPath}`);
  console.log(`File size: ${(ts.length / 1024).toFixed(1)} KB`);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
